class Solution {
public:
    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
        if (initial.empty()) return 0;
        int n = graph.size();
        set<int> unClean(initial.begin(), initial.end()), clean;
        for (int i = 0; i < n; ++i) if (!unClean.count(i)) clean.insert(i);
        
        vector<int> fa(n, -1);
        for (auto i : clean) {
            for (auto j : clean) {
                if (graph[i][j]) Union(i, j, fa);
            }
        }
        
        unordered_map<int, unordered_set<int>> cnt; //<fa, unclean_set>
        unordered_map<int, unordered_set<int>> neigbor;//<unclean, clean_neigbor_set>
        for (auto i : initial) {
            for (auto j : clean) {
                if (graph[i][j]) {
                    cnt[find(j, fa)].insert(i);
                    neigbor[i].insert(find(j, fa));
                }
            }
        }

        int res = -1, maxcnt = -1;

        for (auto i : unClean) {
            int sum = 0;
            for (auto j : neigbor[i]) {
                if (cnt[j].size() == 1) 
                    sum -= fa[j];
            }
            if (sum > maxcnt) {
                maxcnt = sum;
                res = i;
            }
        }
        return maxcnt == -1 ? *unClean.begin() : res;
    }
    
    int find(int x, vector<int> &fa) {
        return fa[x] < 0 ? x : (fa[x] = find(fa[x], fa));
    }
    
    void Union(int x, int y, vector<int> &fa) {
        int fax = find(x, fa);
        int fay = find(y, fa);
        if (fax != fay) {
            fa[fay] += fa[fax];
            fa[fax] = fay;
        }
    }
};